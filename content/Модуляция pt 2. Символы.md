---
title: Модуляция pt 2.  Символы.
draft: false
tags:
  - DSP
  - sdr
  - tx
date: 2024-12-24T00:00:00
permalink: modulation-2
---
Как показано ранее [[Модуляция pt 1.  IQ - отсчеты.]]  для передачи некоторой последовательности бит, предварительно ее необходимо представить в виде двух функций $I(t)$ и $Q(t)$. Возникает закономерный вопрос: как отобразить последовательность в такие функции?

>[!Note] Определение
>Пусть $b(t)$ - исходная последовательность бит.  Последовательность $m(t) = Map(b(t))$  комплексных чисел будем называть последовательностью **символов**.

Следовательно, необходимо выбрать отображение $Map(b(t))$


## PAM (Pulse Amplitude Modulation)

Пусть 
$$
Map(b(t)) = 
\begin{cases}
  \ \ \  1, &   если \ \ b(t) = 1 \\
-1, & если \ \ b(t) = 0
\end{cases}
$$
Каждый бит исходого сообщения кодируется одним вещественным числом. 

>[!warning] Замечание
> В данном случае $Q(t) \equiv 0 \ \   \forall t$.

Результат такого отображения удобно рассматривать на комплексной плоскости.  Этот график называется созвездием. 
![[BPSK_Gray_Coded.svg|300]] 
## QAM (Quadrature Amplitude Modulation)

$$
Map(b(t)) = 
\begin{cases}
\ \ \ 1 + i, &   если \ \ b(t) = 11 \\
\ \ \ 1 - i, & если \ \ b(t) = 10 \\
-1 + i, & если \ \ b(t) = 01 \\
-1 - i, & если \ \ b(t) = 10
\end{cases}
$$
![[QPSK_Gray_Coded.svg|300]]

## M - QAM 

Можна так же кодировать произвольное число бит:
![[QPSK-16QAM-and-64QAM-Modulation-Constellations.png]]
На рисунке изображены созведия для QAM, 16-QAM, 64-QAM.


## Длительность

К сожалению, передача одного символа оказывается неэффективной. Из свойств преобразования Фурье следует, что в таком случае мы будем занимать весь доступный спектр. Для решения этой проблемы, необходимо придать каждому символу длительность $T_s$. 

Возьмем наше сообщение $m(t)$ и между каждым символом вставим $T_s - 1$ ноль.
[[Тестовая заметка про интерполяцию|В результате, спектр нашего сообщения просуммируется $T_s$ раз]]. Поэтому необходимо применить фильтр. Такой фильтр будем называть **формирующим**. 

В качесте таких фильтров можно взять:
- [Прямоугольную функцию](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F) с длиной носителя $T_s$
- [Приподнятый косинус](https://en.wikipedia.org/wiki/Raised-cosine_filter)
- [Корень из приподнятого косинуса](https://en.wikipedia.org/wiki/Root-raised-cosine_filter)
- [Функцию Гаусса](https://en.wikipedia.org/wiki/Gaussian_filter)

Пример кода с разными формирующими фильтрами и модулцией, можно посмотреть [тут](https://github.com/VeryBaDWerewolf/sdr_course/blob/main/notebooks/pulse_shaping.ipynb).

